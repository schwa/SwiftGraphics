import CoreGraphicsSupport
import Projection
import Shapes3D
import SwiftUI
import SIMDSupport

struct PointCloudSoftwareRenderView: View, DemoView {
    @State
    var cameraTransform: Transform = .translation([0, 0, -5])

    @State
    var cameraProjection: Projection = .perspective(.init())

    @State
    var ballConstraint = BallConstraint()

    @State
    var rasterizerOptions = Rasterizer.Options.default

    @State
    var points: [SIMD3<Float>]

    init() {
        let url = Bundle.main.url(forResource: "cube_points", withExtension: "pointsply")!
        points = try! Ply(url: url).points
        print(points.count)
    }

    var body: some View {
        Canvas { context, size in
            let projection = Projection3DHelper(size: size, cameraProjection: cameraProjection, cameraTransform: cameraTransform)
            context.draw3DLayer(projection: projection) { context2D, context3D in
                context3D.drawAxisMarkers()
                context3D.rasterize(options: rasterizerOptions) { rasterizer in

                    for position in points {
                        let position2D = projection.worldSpaceToScreenSpace(position * 2)

                        let path = Path(ellipseIn: CGRect(center: position2D, radius: 0.5))
                        context2D.fill(path, with: .color(.pink))


                    }


                    //                    for model in models {
//                        for (index, polygon) in try! model.toPolygons().enumerated() {
//                            rasterizer.fill(polygon: polygon.vertices.map(\.position), with: .color(Color(rgb: kellyColors[index % kellyColors.count]).opacity(0.8)))
//                        }
//                    }
                }
            }
        }
        .onChange(of: ballConstraint.transform, initial: true) {
            cameraTransform.matrix = ballConstraint.transform
        }
        .overlay(alignment: .topTrailing) {
            CameraRotationWidgetView(ballConstraint: $ballConstraint)
                .frame(width: 120, height: 120)
        }
        .ballRotation($ballConstraint.rollPitchYaw)
    }
}

let plyFile = """
ply
format ascii 1.0
comment Generated by point_cloud
element point 60
property float x
property float y
property float z
end_header
0.5 0 -0.5
-0.17528224 -0.4301598 -0.5
0.14943564 0.1396805 -0.5
0.47415376 -0.29047918 -0.5
0.20112848 -0.279361 -0.5
-0.000000059604645 0.50000006 -0.5
-0.24512242 -0.17528223 -0.5
-0.4902448 0.14943564 -0.5
0.26463294 0.47415376 -0.5
-0.019510508 0.20112848 -0.5
0.5 0 0.5
-0.17528224 -0.4301598 0.5
0.14943564 0.1396805 0.5
0.47415376 -0.29047918 0.5
0.20112848 -0.279361 0.5
-0.000000059604645 0.50000006 0.5
-0.24512242 -0.17528223 0.5
-0.4902448 0.14943564 0.5
0.26463294 0.47415376 0.5
-0.019510508 0.20112848 0.5
0.5 -0.5 0
-0.17528224 -0.5 -0.4301598
0.14943564 -0.5 0.1396805
0.47415376 -0.5 -0.29047918
0.20112848 -0.5 -0.279361
-0.000000059604645 -0.5 0.50000006
-0.24512242 -0.5 -0.17528223
-0.4902448 -0.5 0.14943564
0.26463294 -0.5 0.47415376
-0.019510508 -0.5 0.20112848
0.5 0.5 0
0.5 -0.17528224 -0.4301598
0.5 0.14943564 0.1396805
0.5 0.47415376 -0.29047918
0.5 0.20112848 -0.279361
0.5 -0.000000059604645 0.50000006
0.5 -0.24512242 -0.17528223
0.5 -0.4902448 0.14943564
0.5 0.26463294 0.47415376
0.5 -0.019510508 0.20112848
-0.5 0.5 0
0.17528224 0.5 -0.4301598
-0.14943564 0.5 0.1396805
-0.47415376 0.5 -0.29047918
-0.20112848 0.5 -0.279361
0.000000059604645 0.5 0.50000006
0.24512242 0.5 -0.17528223
0.4902448 0.5 0.14943564
-0.26463294 0.5 0.47415376
0.019510508 0.5 0.20112848
-0.5 -0.5 0
-0.5 0.17528224 -0.4301598
-0.5 -0.14943564 0.1396805
-0.5 -0.47415376 -0.29047918
-0.5 -0.20112848 -0.279361
-0.5 0.000000059604645 0.50000006
-0.5 0.24512242 -0.17528223
-0.5 0.4902448 0.14943564
-0.5 -0.26463294 0.47415376
-0.5 0.019510508 0.20112848
"""

extension Ply.Element.Row.Value {
    var float: Float? {
        if case let .float(float) = self {
            return float
        }
        return nil
    }
}

extension Ply.Element.Row {
    func to(definition: Ply.Header.Element, ofType: SIMD3<Float>.Type) -> SIMD3<Float>? {
        guard let x = values[0].float, let y = values[1].float, let z = values[2].float else {
            return nil
        }
        return [x, y, z]
    }
}

extension Ply {
    var points: [SIMD3<Float>] {
        elements[0].rows.map {
            $0.to(definition: elements[0].definition, ofType: SIMD3<Float>.self)!
        }
    }
}
